<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹퍼블리셔 박진솔의 포트폴리오 홈페이지</title>
    <link rel="stylesheet" href="./css/reset.css">
    <link rel="stylesheet" href="./css/common.css">
    <link rel="stylesheet" href="./css/font.css">

    <link rel="stylesheet" href="./css/style-1920.css">
    <link rel="stylesheet" href="./css/style-1024.css">
    <link rel="stylesheet" href="/css/style-768.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
</head>
<body>
    <main>
        <div class="hero">
            <div class="common-frame">   
                <p> <strong>WEB PUBLISHER</strong> 박진솔</p>
                <h1>Eternal Glow</h1>
                <h4>사라지지 않는 빛</h4>
            </div>
        </div>

        <div class="aboutme-title">
            
        </div>

        <div class="aboutme">
            <div class="common-frame">
                <div class="about-content">
                    <div class="about-intro">
                        <h2>Like a star that never fades <br> — I complete my light.</h2>
                        <p>쉽게 사라지지 않는 별처럼, 끝까지 빛을 완성합니다.</p>
                        <p>조용하지만 꾸준히 빛나는 ‘별’ 같은 디자이너, 박진솔입니다.</p>
                    </div>
                    <div class="about-txt">
                        <div class="txt-box">
                            <h3>Small Light, Steady Path</h3>
                            <p>작은 빛으로 시작하는 디자인</p>
                            <p>저는 화려함보다는 꾸준함으로 스스로를 증명하는 사람입니다. <br>
                                작은 별이 끝없이 어둠 속을 비추듯, <br>
                                디자인에서도 매 순간 진심으로 임하며 자신만의 색을 쌓아가고 있습니다. <br>
                                눈에 띄지 않아도, 꾸준히 밝히는 빛이 누군가에게 길이 되길 바랍니다.</p>            
                        </div>

                        <div class="txt-box">
                            <h3>Resilience in Every Change</h3>
                            <p>흔들려도 사라지지 않는 중심</p>
                            <p>디자인의 흐름은 늘 변하지만, 그 안에서 나만의 기준과 중심을 잃지 않으려 합니다. <br>
                                프로젝트의 방향이 바뀌거나 일정이 빠듯한 상황에서도 <br>
                                끝까지 책임감을 가지고 완성도를 높이는 일에 집중합니다. <br>
                                그 과정에서 저는 협업의 조화를 배우고, 팀 안에서 신뢰를 쌓아가며 성장했습니다.</p>
                        </div>

                        <div class="txt-box">
                            <h3>Design that Illuminates Hearts</h3>
                            <p>마음을 비추는 디자인</p>
                            <p>저에게 디자인은 단순한 시각 표현이 아니라 ‘감정을 전달하는 언어’입니다. <br>
                                사용자의 시선과 감정을 이해하고, 그 안에서 따뜻한 경험을 만들어내는 것<br>
                                — 그것이 제가 추구하는 디자인입니다. <br>
                                별이 밤하늘을 비추듯, 제 디자인도 누군가의 일상 속 작은 위로와 영감이 되기를 바랍니다.</p>
                        </div>
                    </div>
                    <span class="about-trigger" aria-hidden="true"></span>
                </div>
            </div>
        </div>

    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const txtBoxes = Array.from(document.querySelectorAll('.txt-box'));
            const aboutContent = document.querySelector('.about-content');
            const trigger = document.querySelector('.about-trigger');
            let currentIndex = -1;
            let isAnimating = false;
            let isLocked = false;
            let triggerActivated = false;
            const animationDelay = 350;
            const observerOptions = {
                root: null,
                threshold: 0.6
            };

            if (!aboutContent || txtBoxes.length === 0) {
                return;
            }

            if (trigger) {
                const observer = new IntersectionObserver(function (entries) {
                    entries.forEach(function (entry) {
                        if (entry.isIntersecting) {
                            triggerActivated = true;
                            observer.disconnect();
                        }
                    });
                }, observerOptions);

                observer.observe(trigger);
            } else {
                triggerActivated = true;
            }

            function startAnimationCooldown() {
                isAnimating = true;
                setTimeout(function () {
                    isAnimating = false;
                }, animationDelay);
            }

            function lockScroll() {
                if (isLocked) return;
                isLocked = true;
                document.body.classList.add('no-scroll');
            }

            function unlockScroll() {
                if (!isLocked) return;
                isLocked = false;
                document.body.classList.remove('no-scroll');
            }

            function setVisibleBox(index) {
                if (index < 0) {
                    txtBoxes.forEach(function (box) {
                        box.classList.remove('visible');
                    });
                    currentIndex = -1;
                    return;
                }

                txtBoxes.forEach(function (box, i) {
                    if (i === index) {
                        box.classList.add('visible');
                    } else {
                        box.classList.remove('visible');
                    }
                });
                currentIndex = index;
            }

            function showNextBox() {
                const nextIndex = Math.min(currentIndex + 1, txtBoxes.length - 1);
                if (nextIndex === currentIndex) {
                    return false;
                }
                setVisibleBox(nextIndex);
                return true;
            }

            function showPreviousBox() {
                if (currentIndex < 0) {
                    return false;
                }
                const prevIndex = currentIndex - 1;
                setVisibleBox(prevIndex);
                return true;
            }

            window.addEventListener('wheel', function (event) {
                const rect = aboutContent.getBoundingClientRect();
                const reachedBottom = rect.bottom <= window.innerHeight;
                const reachedTop = rect.top >= 0;
                const inViewport = rect.top < window.innerHeight && rect.bottom > 0;
                const isScrollDown = event.deltaY > 0;
                const isScrollUp = event.deltaY < 0;

                if (!triggerActivated) {
                    return;
                }

                if (!isLocked) {
                    if (!inViewport) {
                        return;
                    }

                    if (isScrollDown) {
                        event.preventDefault();
                        lockScroll();
                        if (!showNextBox()) {
                            unlockScroll();
                            setVisibleBox(txtBoxes.length - 1);
                        } else {
                            startAnimationCooldown();
                        }
                    } else if (isScrollUp && currentIndex >= 0) {
                        event.preventDefault();
                        lockScroll();
                        if (!showPreviousBox()) {
                            unlockScroll();
                            setVisibleBox(0);
                        } else {
                            startAnimationCooldown();
                        }
                    }
                    return;
                }

                if (isAnimating) {
                    event.preventDefault();
                    return;
                }

                if (isScrollDown) {
                    const changed = showNextBox();
                    if (changed) {
                        event.preventDefault();
                        startAnimationCooldown();
                    } else {
                        unlockScroll();
                        setVisibleBox(txtBoxes.length - 1);
                    }
                } else if (isScrollUp) {
                    const changed = showPreviousBox();
                    if (changed) {
                        event.preventDefault();
                        startAnimationCooldown();
                    } else {
                        unlockScroll();
                    }
                }
            }, { passive: false });
        });
    </script>
</body>
</html>